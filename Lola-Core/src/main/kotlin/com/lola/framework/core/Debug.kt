package com.lola.framework.core

import com.fasterxml.jackson.annotation.JsonFilter
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.ser.PropertyWriter
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider
import io.github.oshai.kotlinlogging.KotlinLogging


var limit = 2000
var depth = 1

private val mockitoRegex = Regex("\\\$MockitoMock\\\$.+")

@JsonFilter("BadPropertiesFilter")
private class BadPropertiesFilterMixin

private val mapper = ObjectMapper().also {
    it.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)

    val filterProvider =
        SimpleFilterProvider().addFilter("BadPropertiesFilter", object : SimpleBeanPropertyFilter() {
            override fun serializeAsField(
                pojo: Any?,
                jgen: JsonGenerator,
                provider: SerializerProvider,
                writer: PropertyWriter
            ) {
                if (writer.type.typeName.contains("mockito")) {
                    return
                }
                runCatching {
                    if (calcDepth(jgen) > depth) {
                        writer.serializeAsPlaceholder("", jgen, provider)
                    } else {
                        super.serializeAsField(pojo, jgen, provider, writer)
                    }
                }
            }

            override fun serializeAsElement(
                elementValue: Any?,
                jgen: JsonGenerator,
                provider: SerializerProvider,
                writer: PropertyWriter
            ) {
                if (calcDepth(jgen) > depth) {
                    writer.serializeAsPlaceholder("", jgen, provider)
                } else {
                    super.serializeAsElement(elementValue, jgen, provider, writer)
                }
            }

            private fun calcDepth(jgen: JsonGenerator): Int {
                var sc = jgen.outputContext
                var depth = -1
                while (sc != null) {
                    sc = sc.parent
                    depth++
                }
                return depth
            }
        })
    it.setFilterProvider(filterProvider)
    it.addMixIn(Any::class.java, BadPropertiesFilterMixin::class.java)
}

/**
 * Converts any object to its JSON string representation. This string is shortened to fit in [limit] + 3 chars.
 * String includes simple class name and json object tree.
 * Mockito generated members will be removed from json tree.
 * If class is generated by mockito (mock or spy object), its name will end with *.
 * If some property in tree deeper than [depth], "{}" will be written instead of subtree.
 * If object is null, the result is string "null".
 * This method only should be used as better [toString] for debug.
 */
fun Any?.toJSON(): String {
    return this?.let {
        val json = mapper.writeValueAsString(it)
        val shorted = json.substring(0, limit.coerceAtMost(json.length))
        val jsonStr = if (shorted.length < json.length) "$shorted..." else shorted
        val className = this::class.simpleName?.replace(mockitoRegex, "*") ?: "..."

        "[$className] $jsonStr"
    } ?: "null"
}

internal val log = KotlinLogging.logger("Lola-Core")
